
# Memo

## ポインタ
- Go言語ポインタ(参考: https://goo.gl/JNvhfj)
  - C言語でおなじみのポインタですが、Go言語にもポインタがあります。 宣言する方法もC言語と同じで、たとえばint型変数のポインタは、「*int」と記述します。変数のアドレスを取得するときも、C言語と同様に「&」をつけ、アドレスから変数の中身へアクセスする時は 「`*`」を使います。
  - 変数とは、メモリのアドレスに付けられた名前のこと」です。
いいですか、`「変数c」があるのではなくて、「0x7fffffffe494」という場所（アドレス）に「変数c」という名前を付けている`んです。
  - アドレスはどう決まるの？
じゃあ「0x7fffffffe494」が「変数c」だと誰が決めたんでしょうか。
プログラマーではないですね？だって最初に書いたc言語のコードには、「0x7fffffffe494」なんて書いてません。
  - 正解はコンパイラです。コンパイラが、「変数cという場所が必要なようだから、そのぶんメモリを用意しておこう。0x7fffffffe494を変数cと名付けよう」と決めているんです。なので、コンパイラの種類によっては他のメモリアドレスが割当たることもあります。
コンパイラがこういったことを考えてくれるおかげで、われわれプログラマーは「変数c」というものの正体を深く考えずにプログラミングできるわけです。
  - ポインタは、「メモリ上の他のアドレスを指す変数」です。
  - Pointerを使う理由
    - サイズの大きな変数を効率よく扱う
      - C言語は、関数の引数として値を渡す際に、「引数用のアドレス」に変数をコピーします。int型やchar型のような小さい変数であれば問題ないですが、大きなサイズの構造体を引数に取るような関数の場合、メモリコピーにCPUを使ってしまって性能が落ちてしまいます。どれだけ大きな構造体でも、先頭のアドレスだけ渡してしまえば効率よくやり取りできます
    - 関数の返り値が一つしかありません。そのため、2つ以上の値を返却したい場合に、ポインタを利用して値を返す
```
void warizan(int warareru, int waru, int* syou, int* amari)
{
  *syou = warareru / waru;
  *amari = warareru % waru;
}

void main ()
{
  int a;
  int b;
  int c;
  int d;
  a = 17;
  b = 5;
  warizan(a, b, &c, &d);
  // c = 3, d = 2になる
}
```

- 値渡し
  - ある変数を関数の引数として渡す場合、値のコピーが渡されます。そのため呼び出された関数内で変数の値を変更しても、元の値には影響がありません。これを「値渡し」と呼びます。  
- ポインタ渡し
  - ポインタ変数を関数に渡した場合は、ポインタが指し示す値が、呼び出し元も、呼び出された方も同じものであるため、呼び出された関数内で元の値を変更することができます。これを「ポインタ渡し（または参照渡し）」と呼びます。

**値渡しとポインタ渡しの簡単な例**
```
package main

import "fmt"

func call(a int, b *int){
  a = a + 1
  *b = *b + 1
}

func main(){
  a,b := 5,5

  call(a, &b)
  fmt.Println("値渡し", a) // ---> 値渡し 5
  fmt.Println("ポインタ渡し", b) // ---> ポインタ渡し 6
}
```


(参考： https://goo.gl/QgMk8a)


- ポインタ配列
  - Go 言語の配列名は配列の先頭アドレスを表していません。また、配列にアドレス演算子を適用すると、配列へのポインタが生成されますが、それは配列の先頭アドレスを表しているわけではありません。Go 言語の配列はひとつの「値」なので、配列へのポインタは配列そのものを指し示すことになります。


### メソッドの `ポインタレシーバ` と `変数レシーバ`

```
type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func ScaleFunc(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

```

- ポイントレシーバ
  - 呼び出し時に、変数、または、ポインタのいずれかのレシーバとして取ることができる

```
var v Vertex
ScaleFunc(v)  // Compile error!
ScaleFunc(&v) // OK

var v Vertex
v.Scale(5)  // OK
p := &v
p.Scale(10) // OK
```

- 変数レシーバ
  - メソッドが変数レシーバである場合、呼び出し時に、変数、または、ポインタのいずれかのレシーバとして取ることができる

```
var v Vertex
fmt.Println(AbsFunc(v))  // OK
fmt.Println(AbsFunc(&v)) // Compile error!

var v Vertex
fmt.Println(v.Abs()) // OK
p := &v
fmt.Println(p.Abs()) // OK
```

### ポインタレシーバを使う理由

1. メソッドがレシーバが指す先の変数を変更するため
2. メソッドの呼び出し毎に変数のコピーを避けるため。 例えば、レシーバが大きな構造体である場合に効率的!
