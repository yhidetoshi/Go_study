## Array
- メモリ配置を厳密に指定したいとき、メモリの割り当てを回避したいときに役立つ
- 特徴
  - 配列は値。ある配列を他へ代入するとすべての要素がコピーされる
  - すなわち関数に配列を渡すと、関数側ではポインタではなく、その配列のコピーを受け取る

## Slice
- 配列を扱うGo言語のプログラムでは、配列そのままではなく、スライスを多用する
- スライスの要素を変更すると、その元となる配列の対応する要素が変更される
- 同じ元となる配列を共有している他のスライスは、それらの変更が反映される
- ポインターとして扱われる

- Slice-literal
  - スライスのリテラルは長さのない配列リテラルのようなもの

- スライスするときは、それらの既定値を代わりに使用することで上限または下限を省略することができる
```
var a [10]int
```
これらのスライス式は等価

```
a[0:10]
a[:10]
a[0:]
a[:]
```
### Arrayの実体
- 例えばarray変数を別の変数に代入するときは同じデータを持った新たなarrayがallocateされる。結果、それぞれのarrayが持つ値はメモリ上で別の位置に存在し、一方の値を変えてもそれがもう一方に影響することはない。

```
a := [3]int{1, 2, 3}
b := a

// メモリ上で別の位置にある
fmt.Println(&a[0]) // 0xc8200122e0
fmt.Println(&b[0]) // 0xc820012300

b[0] = 0
fmt.Println(a) // [1 2 3]
fmt.Println(b) // [0 2 3]
```

### Sliceの実体: 
- sliceはarrayへの参照を持つデータ構造。slice変数をつくってもそれ自体が値を保持しているわけではない。だからGoのコードで何気なくsliceを作ったときもその裏側では実体としてのarrayが作られている。
- Slice : `s1 := []int{1,2,3}`

```
s1 := []int{1,2,3}
s2 := s1
s2[1] = 0

// 同じarrayを参照しているから当然の結果
fmt.Println(s1) // [1 0 3]
fmt.Println(s2) // [1 0 3] 
```
